<!-- instance methods
 
/*XMLHttpRequest.abort()
Aborts the request if it has already been sent.

XMLHttpRequest.getAllResponseHeaders()
Returns all the response headers, separated by CRLF, as a string, or null if no response has been received.

XMLHttpRequest.getResponseHeader()
Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response.

XMLHttpRequest.open()
Initializes a request.

XMLHttpRequest.overrideMimeType()
Overrides the MIME type returned by the server.

XMLHttpRequest.send()
Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent.

XMLHttpRequest.setAttributionReporting() Secure context Experimental
Indicates that you want the request's response to be able to register an attribution source or trigger event.

XMLHttpRequest.setRequestHeader()
Sets the value of an HTTP request header. You must call setRequestHeader() after open(), but before send().* -->
<!-- The onreadystatechange event in JavaScript is associated with the XMLHttpRequest object. This event is triggered every time the readyState property of the XMLHttpRequest changes. The readyState property holds the status of the XMLHttpRequest, and it can have one of the following values: -->

<!-- 0 (UNSENT): The request has not been initialized.
1 (OPENED): The request has been set up.
2 (HEADERS_RECEIVED): The request has been sent; headers and status are available.
3 (LOADING): Downloading; responseText holds partial data.
4 (DONE): The operation is complete. -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body style="background-color:black;color:aliceblue">
    Lorem ipsum dolor sit amet, consectetur adipisicing elit. Doloribus hic ex fugit, facere ab quas obcaecati, sed et magni maiores earum numquam dicta reprehenderit sapiente. Sint id nam porro in?
</body>
<script>
    const requestURL='https://api.github.com/users/hiteshchoudhary';
const xrh=new XMLHttpRequest();
xrh.open('GET',requestURL);
// console.log('hello')
//track ready state
xrh.onreadystatechange=function(){
console.log(xrh.readyState);
if (xrh.readyState === 4) {
            const data = JSON.parse(this.responseText)
            console.log( data);
            console.log(data.followers);
}
}
xrh.send();
const div=document.createElement('div');
div.setAttribute('class','image');
div.style.height='200px';
div.style.width='200px';
div.style.backgroundSize='cover'
div.style.backgroundImage='url("https://avatars.githubusercontent.com/u/11613311?v=4")';
const body=document.querySelector('body');
body.append(div);

</script>
</html>


<!-- The V8 engine is an open-source JavaScript engine developed by Google. It is used in the Google Chrome web browser, as well as in the Node.js runtime environment. V8 compiles JavaScript directly to native machine code before executing it, which makes it very fast.

Key Features of the V8 Engine:
High Performance:

V8 compiles JavaScript to highly optimized machine code using Just-In-Time (JIT) compilation techniques.
It performs optimization steps during runtime to further improve performance.
Memory Management:

V8 has an efficient garbage collector that manages memory allocation and deallocation.
It uses generational garbage collection, which divides objects into two generations: young and old. This approach optimizes the collection process.
Written in C++:

V8 is written in C++ and is highly portable. It can run on various platforms, including Windows, macOS, Linux, and more.
Support for Modern JavaScript:

V8 supports the latest ECMAScript standards, providing developers with access to modern JavaScript features and syntax.
Integration with Node.js:

V8 is the underlying engine used by Node.js, allowing server-side JavaScript execution. This makes it possible to write server applications in JavaScript.
Architecture:
Parser:

The parser takes JavaScript code and parses it into an Abstract Syntax Tree (AST).
The AST is a tree representation of the syntactic structure of the JavaScript code.
Interpreter:

V8 initially uses an interpreter called Ignition, which converts the AST into bytecode.
The bytecode is a low-level representation of the code that the V8 engine can execute.
Compiler:

V8 uses two compilers: the baseline compiler (Ignition) and the optimizing compiler (TurboFan).
Ignition produces bytecode, and TurboFan takes that bytecode and generates optimized machine code.
Garbage Collector:

The garbage collector reclaims memory used by objects that are no longer needed.
V8 uses a generational garbage collection approach, which segregates objects by their age and collects younger objects more frequently.
Example Usage in Node.js:
Hereâ€™s a simple example of using V8 through Node.js to create a basic web server:

javascript
Copy code
const http = require('http');

// Create an HTTP server
const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

// Listen on port 3000
server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});
V8's Role in Chrome:
Browser Integration:
V8 is integrated into the Google Chrome browser, where it executes JavaScript code found on web pages.
It powers the execution of complex web applications, making them faster and more efficient.
Optimizations:
Inline Caching:

V8 uses inline caching to optimize the performance of frequently accessed properties and methods.
It stores the type information of objects to speed up property access and method calls.
Hidden Classes:

V8 creates hidden classes (similar to classes in statically typed languages) for JavaScript objects to optimize property access.
These hidden classes allow V8 to quickly look up properties on objects.
Conclusion:
The V8 engine is a crucial component of modern web development, providing high-performance execution of JavaScript code in both the browser and server environments. Its advanced optimization techniques and efficient memory management make it one of the fastest JavaScript engines available.




 -->
